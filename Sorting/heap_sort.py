# 概念:
#
# 二叉树: 每个节点最多有两个子节点
#
# 满二叉树: 一个二叉树,如果每一层的节点数都到达最大值,则这个二叉树就是满二叉树
#                         eg:           1
#                                    /     \
#                                   /       \
#                                  /         \
#                                 2           3
#                                / \         / \
#                               /   \       /   \
#                              4     5     6     7
#                             / \   / \   / \   / \
#                            8   9 10 11 12 13 14 15
#
# 完全二叉树:叶节点只出现在最下层和次下层,并且最下面一层都集中在该层最左边的若干位置的二叉树
#                         eg:           1
#                                    /     \
#                                   /       \
#                                  /         \
#                                 2           3
#                                / \         / \
#                               /   \       /   \
#                              4     5     6     7
#                             / \   / \   /
#                            8   9 10 11 12
#
# 设一个父节点的编号下标为i,则其左子节点的编号下标为: 2i+1, 其右子节点的下标为: 2i + 2
# 则已知一个左子节点或右子节点的下标为j,其父节点下标为: (j-1) // 2
#
#
# 堆:一种特殊的完全二叉树结构
# 大根堆: 一棵完全二叉树, 满足任意节点都比其孩子节点大
# 小根堆: 一棵完全二叉树, 满足任意节点都比其孩子节点小
#
# 堆排序:利用堆的向下调整性质
# ·假设根节点的左右子树都是堆,但根节点不满足堆的性质
# ·可以根据一次向下的调整使得这个二叉树变成一个堆
#                         eg:           2
#                                    /     \
#                                   /       \
#                                  /         \
#                                 9           7
#                                / \         / \
#                               /   \       /   \
#                              8     5     0     1
#                             / \   /
#                            6   4 3
# 该二叉树满足左右子树都是大根堆,但根节点不满足堆的性质
# 我们要将2进行向下调整, 最终得到一个满足大根堆的二叉树:
#                                       9
#                                    /     \
#                                   /       \
#                                  /         \
#                                 8           7
#                                / \         / \
#                               /   \       /   \
#                              6     5     0     1
#                             / \   /
#                            2   4 3
#
#
# 堆排序过程:
# 1)建立堆
# 2)得到堆顶元素,为该二叉树中最大的元素
# 3)去掉堆顶,将堆最后一个元素放到堆顶,此时可以通过一次向下调整使得堆有序
# 4)此时堆顶的元素为该二叉树中第二大的元素
# 5)重复步骤3,直至堆为空
#
# 如何将给定的待排序列表变为一个大根堆?
# 先将待排序列表按每个元素的编号下标排出一棵二叉树,然后从二叉树的最后一个非叶节点开始,
# 如果该节点中有一个子节点比该节点大,交换这两个节点的位置,如果两个子节点都比该节点大,取两个中较大的那一个与该节点交换位置,
# 该过程从最后一个非叶节点持续到根节点
#



# 向下调整函数的实现:
def sift(li,low,high): #sift函数的时间复杂度是O(logn)
    """

    :param li: 列表
    :param low: 堆的根节点位置
    :param high: 堆的最后一个元素的位置
    :return:
    """

    i = low #i最开始指向根节点
    j = 2*i + 1 #j开始是左孩子
    tmp = li[low] #把根节点先存起来
    while j <= high: #只要j位置有数
        if j + 1 <= high and li[j+1] > li[j]: #如果对于编号下标为i的节点不仅存在左孩子(左孩子编号下标为j),还存在右孩子(右孩子编号下标为j+1),且右孩子比左孩子还要大
            j = j + 1 #将j指向右孩子
        if li[j] > tmp: #如果编号下标为j的子节点比编号下标为i的节点(即i是j的父节点)大
            li[i] = li[j] #将子节点的值放在原先父节点的位置上
            i = j     #再往下看一层
            j = 2 * i + 1
        else: #如果子节点比父节点的值小
            li[i] = tmp  #父节点位置不变,循环提前结束
            break
    else: #如果循环没有提前结束,而是在j = 2*i + 1后发现j已经大于high了,循环结束,那我们会发现存在一个父节点在每次与较大子节点比对过程中一直比它的较大子节点小,
          #在循环中(即每一次的父节点与较大子节点的比较过程),我们完成了将所有较大子节点放在这个父节点的位置上,循环结束后(即所有比对都结束后),我们将这个父节点放在最后一个跟它比对的较大子节点的位置上
        li[i] = tmp


#堆排序的实现
def heap_sort(li):      #堆排序的时间复杂度为O(nlogn),实际表现的话,快速排序会比堆排序稍微快一点
    #109-115行是建堆过程
    #首先要构造堆(即:从二叉树的最后一个非叶节点开始,如果该节点中有一个子节点比该节点大,交换这两个节点的位置,如果两个子节点都比该节点大,取两个中较大的那一个与该节点交换位置,该过程从最后一个非叶节点持续到根节点）
    n = len(li)
    # i代表建堆的时候调整的部分的父节点的下标
    for i in range((n-2)//2,-1,-1): #n-1是树中最后一个元素的编号下标,根据公式:已知一个左子节点或右子节点的下标为j,其父节点下标为: (j-1) // 2, 所以这个树的最后一个非叶节点的编号下标是(((n-1)-1)//2),即(n-2) // 2)
        sift(li,i,n-1) #如果以i为根节点的树下面有很多层,我们很难算出i向下调整时sift函数的high到底应该是多少,
                       # 此处拿树的最后一个节点的编号下标做sift函数的high参数没有问题

    #建完堆后,堆顶元素即为这棵树中最大的元素

    for i in range(n-1,-1,-1):
        #i指向当前堆中最后一个尚未排好序的元素
        li[0], li[i] = li[i],li[0]
        #堆顶元素为这棵树中最大的元素,我们通过将它与树中最后一个尚未排好序的元素互换将它存储在目前堆中最末尾的位置,
        #同时high—1,使得后面排序的变化都不会影响到这个最大元素
        sift(li,0,i-1) #此处high = i-1, 将堆最后一个元素放到堆顶后,此时可以通过一次向下调整使得堆有序,调整后的堆顶的元素又是此时除开排好序的元素后树中最大的元素





